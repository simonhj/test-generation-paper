
\newcommand{\term}{\textit}
\newcommand{\lit}{\texttt}

\section{Rule Modeling and Checking}
\label{sec:model}

In this section, we discuss the notation for modeling business rules and the
static checking for completeness and consistency performed on formally captured
rules.

\begin{figure}[t]
\centering
{\small
\tabcolsep=3pt
\begin{tabular}{lll}
\term{RuleSpec} & ::= & \term{Entities} \term{Operations} \\
\\
\term{Entities} & ::= & \term{Entity} \term{Entities} | $\epsilon$ \\
\term{Entity} & ::= & \term{Enum} | \term{Object} \\
\term{Enum} & ::= & \lit{enum} \term{ID} \{ \term{EnumVals} \} \\
\term{EnumVals} & ::= & \term{ID} \term{EnumVals} | $\epsilon$ \\
\term{Object} & ::= & \lit{object} \term{ID} \{ \term{VarDecl} \} \\
\\
\term{Operations} & ::= & \term{Operation} \term{Operations} | $\epsilon$ \\
\term{Operation} & ::= & \lit{operation} \term{ID} \{ \term{Input}
\term{Creates} \term{Modifies} \term{Rules} \term{Triggers} \} \\
\term{Input} & ::= & \lit{input} : \term{VarDecl} \\
\term{Creates} & ::= & \lit{creates} : \term{VarDecl} \\
\term{Modifies} & ::= & \lit{modifies} : \term{VarDecl} \\
\term{Rules} & ::= & \term{Rule} \term{Rules} | $\epsilon$ \\
\term{Rule} & ::= & \lit{group} \term{ID} \{ \term{RuleParts} \} \\
\term{RuleParts} & ::= & \term{RulePart} \term{RuleParts} | $\epsilon$ \\
\term{RulePart} & ::= & \lit{rule} \term{ID} \{ \lit{pre} : \term{Expr} ;
\lit{post} : \term{Expr} \} \\
\term{Triggers} & ::= & \lit{next} : \term{ID} | $\epsilon$ \\
\\
\term{VarDecl} & ::= & \term{TypeName} : \term{ID} \term{VarDecl} | $\epsilon$
\\
\term{TypeName} & ::= & \lit{int} | \lit{bool} | \lit{float} | \lit{string} |
\lit{set<\term{\textrm{TypeName}}>} | \term{ID} \\
\term{Expr} & ::= & \\
\end{tabular}
}
\caption{Partial rule-modeling syntax.}
\label{fig:model-syntax}
\end{figure}

\subsection{Rule-Modeling Language}

Overall, our approach models rules in the context of operations in the system
under test.  An operation has a set of input entities, a set of created
entities, a set of modified entities, and a set of rules, where each rule
consists of a set of precondition-postcondition pairs. For example,
Figure~\ref{fig:invoice} shows the operation for computing invoice totals in the
\subject{JBilling} application, which takes as input an invoice and modifies
certain attributes. The rules associated with this operation, which govern how
the invoice total and the customer's credit limit are updated, are modeled with
the operation in the form of precondition-postcondition pairs.

Figure~\ref{fig:model-syntax} presents the formal syntax of the rule-modeling
language (for clarity, we omit some of the details and present only the
important parts of the language). A \textit{rule specification} consists of
entities and operations. An \textit{entity} can be an object in the system (\eg
invoice, order, customer) or an enumerated type (\eg a customer's balance type
can be \subject{None}, \subject{Credit}, or \subject{Prepaid}).

The key part of the syntax, which models rules, is based on
operations. Formally, an \textit{operation} ${\cal O}$ is the tuple $(I, C, M,
R, o_t)$, where $I$ is the set of input entities read during the execution of
${\cal O}$, $C$ is the set of entities created by ${\cal O}$, $M$ is the set of
entities whose attributes are modified by ${\cal O}$, $R$ is the set of rules
that describe the behavior of ${\cal O}$, and $o_t$ is an operation, possibly
none, that is automatically triggered in the system after the execution of
${\cal O}$.

A \textit{rule} $R = \{r_1, r_2, \ldots, r_k\}, k \geq 1,$ consists of a set of
rule parts. A \textit{rule part} $r$ is a precondition-postcondition pair, $p
\Longrightarrow q$, where $p$ and $q$ are boolean formulas such that if $p$
holds in the state before the operation, $q$ is true in the state resulting from
the execution of the operation. If the precondition of a rule part is true, we
say that the rule is \textit{applicable}.

Consider the rule illustrated in Figure~\ref{fig:invoice} for the
\subject{Compute Invoice Total} operation. The rule has three rule parts, each
of which consists of a precondition and a postcondition. The first rule part
pertains to the case where the customer's balance type is \subject{None}; the
second rule part is for the case where the balance type is \subject{Credit} and
the credit limit exceeds or equals the order total; the third rule part covers
the case where the balance type is \subject{Credit} and the order total exceeds
the credit limit.

Often in enterprise systems, the execution of an operation or a transaction
automatically triggers other transactions or operations. Our rule-modeling
syntax accommodates this. For example, ...

\subsection{Rule Checking}
 
We impose a few well-formedness constraints on rule specifications to ensure
consistency and completeness, and accuracy of operation chaining for test
generation. These constraints are amenable to automated static checking. Thus,
we envision that the rules can be iteratively refined in a rule editor, based on
automatic (semantic) checking for constraint violations (in addition to
syntactic checking for conformance to the modeling syntax).

\paragraph*{Property 1: Rule-part Disjointedness}
In our notation, a rule part is intended to represent disjoint preconditions so
that when a rule is applicable, the precondition of only one rule part is true;
consequently, there is no ambiguity in identifying the relevant rule part for an
applicable rule. Formally, we define this property as follows. Let $R= \{r_1,
r_2, \ldots, r_k\}$ be a rule such that $k \geq 2$. Then, for all $r_i, r_j \in
R$ where $ r_i \coloneqq (p_i \Longrightarrow q_i)$ and $r_j \coloneqq (p_j
\Longrightarrow q_j)$, $(p_i \wedge p_j)$ must not be satisfiable. A simple
example of a rule specification that violates this property is $p_i = (a > 0)$
and $p_j = (a < 10)$; this specification represents ambiguous behavior when, for
example, $a = 5$.  The rule parts illustrated in Figure~\ref{fig:invoice} have
disjoint preconditions.

To check that a rule satisfies this property, first, we enumerate all pairs of
rule parts for the rule. Then, for each pair of rule parts (with preconditions
$p_i$ and $p_j$), we determine whether the boolean formula $(p_i \wedge p_j)$
has a solution; if it does, we flag a violation of the property.

\paragraph*{Property 2: Rule-part Completeness}
This property is intended to ensure that a rule specifies the complete operation
behavior for the variables mentioned in the rule. Let $R= \{r_1, r_2, \ldots,
r_k\}$ be a rule such that $k \geq 2$ and $r_i \coloneqq (p_i \Longrightarrow
q_i)$. Then, $\neg(p_1 \vee p_2 \vee \ldots \vee p_k)$ must not be
satisfiable. For example, the rule consisting of two rule parts with
preconditions $(a < 5)$ and $(a > 10)$, respectively, violates the completeness
property because the operation behavior for $5 \leq a \leq 10$ is left
unspecified.

To verify this property, our technique checks, for each rule, whether the
formula $\neg(p_1 \vee p_2 \vee \ldots \vee p_k)$ has a solution.

%% \paragraph*{Postcondition uniformness property}
%% This property requires that all postconditions for a rule must assert values for
%% the same set of variables, which ensures that the effect of an operation is
%% consistently specified irrespective of which part of a rule causes the rule to
%% be applicable. \textbf{(Do we need this? Fig 2 violates it.)}

\paragraph*{Property 3: Rule Compatibility}
The rule compatibility property requires that for any set of applicable rules of
an operation, the postconditions of their relevant rule parts must not be
conflicting. To illustrate, consider rules $R_1 = \{r_1\}$ and $R_2 = \{r_2\}$
for an operation, such that $r_1 \coloneqq ((a > 0) \Longrightarrow (total =
10))$, $r_2 \coloneqq ((b > 0) \Longrightarrow (total = 20))$, and the two
preconditions are not disjoint (\ie $(a > 0) \wedge (b > 0)$ is
satisfiable). This pair of rules violates the compatibility property because the
postconditions are conflicting, whereas the corresponding preconditions can be
true simultaneously. In general, let $r_1 \coloneqq (p_1 \Longrightarrow q_1)$
and $r_2 \coloneqq (p_2 \Longrightarrow q_2)$ be the relevant rule parts of two
applicable rules of an operation. Then, if $(p_1 \wedge p_2)$ is satisfiable,
$(q_1 \wedge q_2)$ must be satisfiable.

If two rules violate this property, it might in fact indicate that their rule
parts can be merged into one rule. In the preceding example, $R_1$ and $R_2$
could be merged into one rule with two rule parts $R_m = \{r_{m_1}, r_{m_2}\}$,
where $r_{m_1} \coloneqq (a > 0) \Longrightarrow (total = 10)$ and $r_{m_2}
\coloneqq (a \leq 0 \wedge b > 0) \Longrightarrow (total = 20)$. Note adding the
conjunct $a \leq 0$ (the negation of the precondition of $r_1$) to the
precondition of $r_{m_2}$ makes the two preconditions disjoint, which ensures
that $R_m$ satisfies the rule-part disjointedness property. Alternatively, the
negation of the precondition of $r_2$ could be added to the precondition of
$r_{m_1}$ to satisfy this property.

To verify this property, ...

\paragraph*{Property 4: Rule Dependence}
Finally, we enforce the restriction that there can be no data dependence between
the postcondition of one rule and the precondition of another rule of the same
operation. This property ensures that there is no implicit ordering among the
rules of an operation. When such an ordering exists between two rules of an
operation, the operation should be split into two operations. We formalize this
property as follows. Let ${\cal R} = \{R_1, R_2, \ldots, R_n\}$ be the rules
associated with an operation. For any $R_i, R_j \in {\cal R}$, let $V_{i,
  \mathit{post}}$ be the set of variables used in the postconditions of the rule
parts of $R_i$ and $V_{j, \mathit{pre}}$ be the set of variables used in the
preconditions of the rule parts of $R_j$. Then, $V_{i, \mathit{post}} \cap V_{j,
  \mathit{pre}} = \emptyset$.
