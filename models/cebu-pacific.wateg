Model CebuPacific

ENTITIES
object Ticket {
       FareType:fareType
       int:passengerID
       sector:sector1
       sector:sector2   
}
object Sector {
       Flight:flight
       int:etd //Estimated time of departure
       int:std //schedule time of departure
       Class:bookingClass
       bool:promo
       Status:status
       int:cancelTime
       int:cost
}

object PassengerFund {
       int:balance
       int:passengerID
}

enum FareType {
     Rebookable
     NonRebookable
}

enum Status {
     Scheduled
     CancelledByAirline
     CancelledOtherReason
     CancelledByPassenger
     CancelledInvolountary
     Refunded
     Flown
}

enum Class {
     A    
     B    
     C    
     D    
     E    
     F    
     G    
     H    
     I    
     J    
     K    
     L    
     M    
     N    
     O    
     P    
     Q    
     S    
     T    
     V    
     W    
     X    
     Y    
     Z    
} 

enum Flight {
     C892
     C945
     C536
     C654
}


enum CancellationReason {
     Safety
     PassengerIllness
     Other
}

PAGES

page Y {
	a
}

OPERATIONS

operation partialCancellation {
	  input: Ticket:ticket CancellationReason:reason int:currentTime Sector:sector int:time
	  creates:
	  modifies: Ticket:ticket Sector:sector
	  group reasons {
	  	rule forceMajeur { //9.3.3
		     pre: reason == CancellationReason::Safety AND (sector == ticket.sector1 OR sector == ticket.sector2)  ;
		     post: sector.status == Status::CancelledByAirline AND sector.cancelTime == time;
		}
		rule illness {
		     pre:  reason == CancellationReason::PassengerIllness AND  (sector == ticket.sector1 OR sector == ticket.sector2)  
		     post: sector.status == Status::CancelledInvolountary AND sector.cancelTime == time;
		}		
		rule other { //9.3.4
		      pre: reason == CancellationReason::Other AND (sector == ticket.sector1 OR sector == ticket.sector2) 
		      post: sector.status == Status::CancelledOtherReason AND sector.cancelTime == time;
		}		
	  }		    
}

operation makeSector {
	  input: Flight:flight  int:etd Class:class bool:promo
	  creates: Sector:sector
	  modifies:
	  group b {
	  	rule build {
		     pre: true;
		     post: sector.flight == flight AND sector.etd == etd AND sector.std == etd AND sector.bookingClass == class AND sector.promo == promo 
		     	     AND sector.status == Status::Scheduled;
		}
	  }	  

}

operation addSector {
	  input: Sector:sector Ticket:ticket PassengerFund:fund
	  creates: 
	  modifies: Ticket:ticket
	  group main {
	  	rule addsector {
		     pre: fund.balance > sector.cost;
		     post: (ticket.sector1 == sector OR ticket.sector2 == sector)  AND fund.balance == fund.balance@ - sector.cost;
		}		
	  }	  
}

operation rebookPartial {
	  input: Ticket:ticket Sector:sectorToCancel int:currentTime PassengerFund:fund int:rebookingFee Sector:newSector
	  creates:
	  modifies: Sector:sector Ticket:ticket
	  group clause81a { //Passenger changes reservation with
	  	rule rule1 {
		     pre: ticket.fareType == FareType::Rebookable AND currentTime > sector.etd + 4 AND fund.balance > rebookingFee AND fund.balance > (newSector.cost - sectorToCancel.cost) AND (sectorToCancel  == ticket.sector1 OR sectorToCancel == ticket.sector2) AND newSector.etd < currentTime+720; //30 days
	             post: (sectorToCancel != ticket.sector1 AND sectorToCancel  != ticket.sector2) AND (newSector == ticket.sector1 or newSector == ticket.sector2) AND  fund.balance == fund.balance@ - (newSector.cost - sectorToCancel.cost); 
		}		
	  }
	  group clause81b {
	  	rule involountary{
		     pre: sectorToCancel.status == Status::CancelledInvolountary AND (sectorToCancel == ticket.sector1 OR sectorToCancel == ticket.sector2) AND newSector.etd < currentTime+720; 
		     post: (sectorToCancel != ticket.sector1 AND sectorToCancel != ticket.sector2)  AND (newSector == ticket.sector1 OR newSector == ticket.sector2)
		}	
		rule delay {
		     pre: sectorToCancel.etd > sectorToCancel.std + 3 AND (sectorToCancel == ticket.sector1 AND sectorToCancel == ticket.sector2)  AND newSector.etd < currentTime+720 ;
		     post: (sectorToCancel != ticket.sector1 AND sectorToCancel != ticket.sector2) sec AND (newSector == ticket.sectors1 OR newSector == ticket.sector2)
		}	
	  }	  	  
}

operation refund {
	  input: Ticket:ticket PassengerFund:fund Sector:sector int:currentTime
	  creates:
	  modifies: fund
	  group clause82 {
	    	rule partADelay {
	  	     pre:  (sector == ticket.sector1 OR sector== ticket.sector2) AND sector.std > sector.etd +1;
		     post: sector.status == Status::Refunded AND fund.balance == fund.balance@ + sector.cost
	   	}		
		rule Cancellation {
		     pre:   (sector == ticket.sector1 OR sector== ticket.sector2) AND (sector.status == Status::CancelledByAirline OR sector.status == Status::CancelledOtherReason OR sector.status == Status::CancelledInvolountary)
		     post: : sector.status == Status::Refunded AND fund.balance == fund.balance@ + sector.cost
		}		
	  }	  
	  
}

operation purchaseTicket {
	  input: FareType:fareType
	  creates: Ticket:ticket
	  modifies: PassengerFund:fund
	  group main {
	  	rule r {
	  	     pre: true; 
		     post:  ticket.fareType == fareType;
		}
	  }	  
}

operation delayFlight {
	  input: Sector:sector int:delay
	  creates:
	  modifies: Sector:sector
	  group main {
	  	rule main {
		     pre: sector.status == Status::Scheduled;
		     post: sector.etd == sector.etd@ + delay;
		}
	  }
}

operation flyPart {
	  input: Ticket:ticket Sector:sector
	  creates:
	  modifies: Ticket:ticket Sector:sector
	  group main {
	  	rule main {
		     pre: sector == ticket.sector1 OR sector == ticket.sector2
		     post: sector.status == Status::Flown;
		}		
	  }	  
}

operation createFund {
	  input: int:passengerID int:initialBalance
	  creates: PassengerFund:fund
	  modifies:

	  group create {
      	  	rule create {
      	   	  pre: true;
	  	   post: fund.passengerID == passengerID AND fund.balance == initialBalance;
          }     
      }
}

TRIGGERS

